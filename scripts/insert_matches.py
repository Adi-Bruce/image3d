import argparse
from pathlib import Path
import numpy as np
import torch
import sys

sys.path.insert(1,'/home/brucewayne/image3d/utils')
from colmap_db_writer import ColmapDatabase, image_ids_to_pair_id
from superpoint_superglue import SuperGlueMatcher

IMAGE_EXTS = {".jpg", ".jpeg", ".png", ".bmp", ".tiff", ".webp"}

def main(image_dir, db_path, pairs_path, device):
    image_dir = Path(image_dir)
    pairs_path = Path(pairs_path)

    # Load DB
    db = ColmapDatabase(db_path)
    cur = db.conn.cursor()

    # Map image name -> image_id
    cur.execute("SELECT image_id, name FROM images;")
    name_to_id = {name: image_id for image_id, name in cur.fetchall()}

    # Initialize matcher (SuperGlue will be used here)
    matcher = SuperGlueMatcher(device=device)

    image_names = sorted(name_to_id.keys())
    total_possible = len(image_names) * (len(image_names) - 1) // 2

    # Read pairs file (generated by EfficientNet step). If missing or incomplete,
    # generate/augment with exhaustive pairs from images in the DB.
    pairs = []
    if pairs_path.exists():
        with open(pairs_path, "r") as f:
            for line in f:
                a, b = line.strip().split()
                pairs.append((a, b))
    else:
        pairs_path.parent.mkdir(parents=True, exist_ok=True)

    pair_set = {tuple(sorted(p)) for p in pairs}
    if len(pair_set) < total_possible:
        missing = []
        for i, a in enumerate(image_names):
            for b in image_names[i + 1:]:
                key = tuple(sorted((a, b)))
                if key not in pair_set:
                    missing.append((a, b))
                    pair_set.add(key)
        if missing:
            print(f"[INFO] Adding {len(missing)} missing pairs (total will be {len(pair_set)}).")
            with open(pairs_path, "w") as f:
                for a, b in sorted(pair_set):
                    f.write(f"{a} {b}\n")
        pairs = list(pair_set)

    if not pairs:
        raise RuntimeError("No image pairs found or generated.")

    print(f"Inserting SuperGlue matches for {len(pairs)} image pairs...")

    for name0, name1 in pairs:
        img0 = image_dir / name0
        img1 = image_dir / name1

        if not img0.exists() or not img1.exists():
            print(f"[WARN] Missing image: {name0} or {name1}")
            continue

        # Run SuperGlue
        mkpts0, mkpts1, _ = matcher.match_pair(img0, img1)

        if mkpts0.shape[0] == 0:
            print(f"[INFO] No matches for {name0} <-> {name1}")
            continue

        # Fetch original keypoints to compute indices
        img_id0 = name_to_id[name0]
        img_id1 = name_to_id[name1]

        # Load keypoints from DB
        cur.execute("SELECT rows, cols, data FROM keypoints WHERE image_id=?", (img_id0,))
        rows0, cols0, blob0 = cur.fetchone()
        kpts0 = np.frombuffer(blob0, dtype=np.float32).reshape(rows0, cols0)[:, :2]

        cur.execute("SELECT rows, cols, data FROM keypoints WHERE image_id=?", (img_id1,))
        rows1, cols1, blob1 = cur.fetchone()
        kpts1 = np.frombuffer(blob1, dtype=np.float32).reshape(rows1, cols1)[:, :2]

        # Build index matches by nearest neighbor in keypoint sets
        matches = []
        for p0, p1 in zip(mkpts0, mkpts1):
            idx0 = np.argmin(np.linalg.norm(kpts0 - p0, axis=1))
            idx1 = np.argmin(np.linalg.norm(kpts1 - p1, axis=1))
            matches.append([idx0, idx1])

        matches = np.array(matches, dtype=np.int32)

        # Insert matches
        db.add_matches(img_id0, img_id1, matches)
        db.add_two_view_geometry(img_id0, img_id1, matches, config=2)
        print(f"  {name0} <-> {name1}: {matches.shape[0]} matches")

    db.commit()
    db.close()
    print("SuperGlue matches inserted successfully.")

if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("--image_dir", required=True)
    ap.add_argument("--db_path", default="output/database.db")
    ap.add_argument(
        "--pairs",
        required=True,
        help="pairs.txt from EfficientNet step (if missing, exhaustive pairs are generated)",
    )
    ap.add_argument("--device", default="cuda")
    args = ap.parse_args()

    main(args.image_dir, args.db_path, args.pairs, args.device)
